## Java修饰符
```text
Java修饰符主要分以下两类
    -访问修饰符
    -非访问修饰符
修饰符用来定义类、方法或变量，通常放在语句最前端
```

### 访问控制修饰符
```text
Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。java支持4种不同的访问权限
    -default(即默认，什么也不写)：在同一包内可见，不使用任何修饰符，使用对象：类、接口、变量、方法
    -private：在同一类可见，使用对象：变量、方法。注意：不能修饰类（外部类）
    -public：对所有类可见，使用对象：类、接口、变量、方法
    -protected：对同一包内的类和所有子类可见，使用对象：变量、方法。注意：不能修饰类（外部类）
```

### 默认访问修饰符-不适用任何关键字
```text
使用默认访问修饰符声明的变量和方法，对同一个包内的类是可见的。
接口里的变量都隐式声明为public static final，而接口里的方法默认情况下访问权限为public
```

### 私有访问修饰符-private
```text
-私有访问修饰符是最严格的访问级别，所以被声明为private的方法、变量和构造方法只能被所属类访问，并且类和接口不能声明为private
-声明为私有访问类型的变量只能通过类中公共的getter方法被外部类访问
-Private访问修饰符的使用主要用来隐藏类的实现细节和保护类的数据
```

### 公有访问修饰符-public
```text
-被声明为public的类、方法、构造方法和接口能够被其他任何类访问
-如果几个相互访问的public类分布在不同的包中，则需要导入相应的public类所在的包。由于类的继承性，类所有的公共方法和变量
  都能被子类继承
-Java程序的main()方法必须设置成公有的，否则，Java解释器将不能运行该类
```

### 受保护的访问修饰符-protected
```text
protected需要从以下两点来分析说明
    -子类与基类在同一包中：被声明为protected的变量、方法和构造器能被同一个包中的任何其它类访问
    -子类基类不在同一包中：那么在子类中，子类实例可以访问其从基类继承而来的protected方法，而不能访问基类实例的protected方法
-protected可以修饰数据成员，构造方法，方法成员，不能修饰类（内部类除外）
-接口及接口的成员变量和成员方法不能声明为protected
-子类能访问protected修饰符声明的方法和变量，这样就能保护不相关的类使用这些方法和变量（见Baohu.java）
```

### 访问控制和继承
```text
-父类中声明为public的方法在子类中也必须为public
-父类中声明为protected的方法在子类中要么声明为protected，要么声明为public，不可声明为private
-父类中声明为private的方法，不能被子类继承
```

### 非访问修饰符
```text
-static修饰符，用来修饰类方法和类变量
-final修饰符，用来修饰类，方法和变量，final修饰的类不能被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，不可修改
-abstract修饰符，用来创建抽象类和抽象方法
-synchronized和volatile修饰符，主要用于线程的编程
```

#### static修饰符
```text
静态变量：
    -static关键字用来声明独立于对象的静态变量，无论一个类实例化多少对象，它的静态变量只有一份拷贝，静态变量也被称为类变量
      局部变量不能声明为static变量
静态方法：
    -static关键字用来声明独立于对象的静态方法，静态方法不能使用类的非静态变量，静态方法从参数列表得到数据，然后计算这些数据
对类变量和方法的访问可以直接使用classname.variablename和classname.methodname的方式访问
```

#### final修饰符
```text
final变量
    -final变量一旦赋值后，不能被重新赋值，被final修饰的实例变量必须显示指定初始值
    -final修饰符通常和static修饰符一起使用来创建类常量，例如：public static final MAXSIZE = 100;
final方法
    -父类中的final方法可以被子类继承，但不能被子类重写
    -声明final方法的主要目的是防止该方法的内容被修改
final类
    -final类不能被继承，没有类能继承final类的任何特性
```

#### abstract修饰符
```text
抽象类：
    -抽象类不能用来实例化对象，声明抽象类的唯一目的是为了将来对该类进行扩充
    -一个类不能同时被final和abstract修饰。如果一个类包含抽象方法，那么该类一定要声明为抽象类，否则将出现编译错误
    -抽象类可以包含抽象方法和非抽象方法
抽象方法：
    -抽象方法是一种没有任何实现的方法，该方法的具体实现由子类提供
    -抽象方法不能声明为final和static
    -任何继承抽象类的子类必须实现父类的所有抽象方法，除非该子类也是抽象类
    -如果一个类包含若干个抽象方法，那么该类必须声明为抽象类，抽象类可以不包含抽象方法
    -抽象方法的声明以分号结尾，例如： public abstract example();
```

#### transient修饰符
```text
-序列化的对象包含被transient修饰的实例变量时，java虚拟机（JVM）跳过该特定的变量
-该修饰符包含在定义变量的语句中，用来预处理类和变量的数据类型
    例如：public transient int limit = 55;这种声明方式不会持久化，而public int b;是持久化的
```

#### synchronized修饰符
```text
synchronized关键字声明的方法同一时间只能被一个线程访问，synchronized修饰符可以应用于四个访问修饰符
例如： public synchronized void showInfo(){......};
```

#### volatile修饰符
```text
-volatile修饰的成员变量在每次被线程访问时，都强制从共享内存中重新读取该成员变量值，而且，当成员变量发生变化时，会强制线程
变化值回写到共享内存，这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值
-一个volatile对象引用可能是null
```